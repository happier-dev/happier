ci:
  commands:
    # IMPORTANT (Hapsta discipline):
    # - Evidence commands MUST run via `hapsta` (not raw yarn/expo/tsc/docker).
    # - Evidence is expected to be stack-scoped (use `hapsta edison --stack=<name> ...`),
    #   which sets HAPPIER_STACK_STACK + HAPPIER_STACK_ENV_FILE for the commands below.
    # Task-frontmatter templating is supported (Edison fills {{stack}} / {{components_csv}} from the task file).
    # Fail-closed rules:
    # - If task has no stack, evidence capture must fail.
    # - If env stack is set (via hapsta edison --stack=...), it must match the task stack.
    # - If task declares components, pass them as positional args to stack-scoped commands.
    type-check: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPIER_STACK_STACK:?Run via: hapsta edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; IFS="," read -r -a COMPS <<< "{{components_csv}}"; node ./bin/hapsta.mjs stack typecheck "$TASK_STACK" "${COMPS[@]}"'
    lint: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPIER_STACK_STACK:?Run via: hapsta edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; IFS="," read -r -a COMPS <<< "{{components_csv}}"; node ./bin/hapsta.mjs stack lint "$TASK_STACK" "${COMPS[@]}"'
    build: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPIER_STACK_STACK:?Run via: hapsta edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; OUT_DIR="$PWD/.edison/_tmp/ui-build/$TASK_STACK"; export HAPPIER_STACK_UI_BUILD_DIR="$OUT_DIR"; COMPS_CSV="{{components_csv}}"; case ",$COMPS_CSV," in (*,happy,*) node ./bin/hapsta.mjs stack build "$TASK_STACK" ;; (*) node ./bin/hapsta.mjs stack build "$TASK_STACK" -- --no-ui ;; esac'
    test: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPIER_STACK_STACK:?Run via: hapsta edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; IFS="," read -r -a COMPS <<< "{{components_csv}}"; node ./bin/hapsta.mjs stack test "$TASK_STACK" "${COMPS[@]}"'
    track-coherence: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPIER_STACK_STACK:?Run via: hapsta edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; node ./bin/hapsta.mjs edison track:coherence "{{task_id}}" --source=upstream --targets=fork,integration --json --max-lines=80'
    task-diff: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPIER_STACK_STACK:?Run via: hapsta edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; REMOTE_DEFAULT="${HAPPIER_STACK_STACK_REMOTE:-upstream}"; dir="${HAPPIER_STACK_REPO_DIR:?ERROR: missing HAPPIER_STACK_REPO_DIR (use hapsta wt use ... or hapsta stack wt <stack> -- use ...)}"; echo "=== task-diff ==="; echo "task: {{task_id}}"; echo "stack: $TASK_STACK"; echo "repo: $dir"; echo "stackRemote: ${REMOTE_DEFAULT}"; echo ""; remote="$REMOTE_DEFAULT"; if ! git -C "$dir" remote get-url "$remote" >/dev/null 2>&1; then echo "ERROR: remote not found in repo: $remote"; git -C "$dir" remote -v || true; exit 1; fi; headref="$(git -C "$dir" symbolic-ref -q "refs/remotes/$remote/HEAD" 2>/dev/null || true)"; if [ -n "$headref" ]; then defaultBranch="${headref##*/}"; else defaultBranch="$(git -C "$dir" remote show "$remote" 2>/dev/null | sed -n "s/^  HEAD branch: //p" | head -1)"; fi; if [ -z "$defaultBranch" ]; then defaultBranch="main"; fi; if ! git -C "$dir" show-ref --quiet "refs/remotes/$remote/$defaultBranch"; then echo "ERROR: cannot resolve base ref refs/remotes/$remote/$defaultBranch"; echo "Hint: ensure $remote has a HEAD/default branch configured."; exit 1; fi; baseRef="$remote/$defaultBranch"; echo "baseRef: $baseRef"; echo ""; echo "--- status (porcelain) ---"; git -C "$dir" status --porcelain=v1 || true; echo ""; echo "--- commits on branch (baseRef..HEAD) ---"; git -C "$dir" log --oneline --no-decorate "$baseRef..HEAD" || true; echo ""; echo "--- diffstat (baseRef...HEAD) ---"; git -C "$dir" diff --stat "$baseRef...HEAD" || true; echo ""; echo "--- full diff (baseRef...HEAD) ---"; git -C "$dir" diff "$baseRef...HEAD" || true; echo ""'
    coderabbit: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPIER_STACK_STACK:?Run via: hapsta edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; REMOTE_DEFAULT="${HAPPIER_STACK_STACK_REMOTE:-upstream}"; dir="${HAPPIER_STACK_REPO_DIR:?ERROR: missing HAPPIER_STACK_REPO_DIR (use hapsta wt use ... or hapsta stack wt <stack> -- use ...)}"; echo "=== coderabbit ==="; echo "task: {{task_id}}"; echo "stack: $TASK_STACK"; echo "repo: $dir"; echo "stackRemote: ${REMOTE_DEFAULT}"; echo ""; fail=0; remote="$REMOTE_DEFAULT"; if ! git -C "$dir" remote get-url "$remote" >/dev/null 2>&1; then echo "ERROR: remote not found in repo: $remote"; git -C "$dir" remote -v || true; exit 1; fi; headref="$(git -C "$dir" symbolic-ref -q "refs/remotes/$remote/HEAD" 2>/dev/null || true)"; if [ -n "$headref" ]; then defaultBranch="${headref##*/}"; else defaultBranch="$(git -C "$dir" remote show "$remote" 2>/dev/null | sed -n "s/^  HEAD branch: //p" | head -1)"; fi; if [ -z "$defaultBranch" ]; then defaultBranch="main"; fi; if ! git -C "$dir" show-ref --quiet "refs/remotes/$remote/$defaultBranch"; then echo "ERROR: cannot resolve base ref refs/remotes/$remote/$defaultBranch"; echo "Hint: ensure $remote has a HEAD/default branch configured."; exit 1; fi; baseRef="$remote/$defaultBranch"; echo "baseRef: $baseRef"; echo ""; echo "--- coderabbit review (all, base=$baseRef) ---"; tmp="$(mktemp)"; coderabbit review --plain --no-color --type all --base "$baseRef" --cwd "$dir" 2>&1 | tee "$tmp"; code="${PIPESTATUS[0]}"; if [ "$code" -ne 0 ]; then echo "ERROR: coderabbit exited non-zero (code=$code)"; fail=1; fi; if grep -Eiq "^[[:space:]]*Error:[[:space:]]|Git repository not found\\." "$tmp"; then echo "ERROR: coderabbit produced an error message (see output above)"; fail=1; fi; if grep -Eiq "^[[:space:]]*Type[[:space:]]*:[[:space:]]*(security_issue|critical_issue|bug)\\b" "$tmp"; then fail=1; fi; rm -f "$tmp"; echo ""; if [ "$fail" -ne 0 ]; then echo "Result: FAIL (blocking findings detected, or coderabbit failed)"; exit 1; fi; echo "Result: PASS (no blocking findings detected)"; exit 0'

  # Optional baseline multi-repo fingerprint inputs.
  # Hapsta wrappers (`hapsta edison --stack=...`) will override these at runtime to include
  # the stackâ€™s resolved repo checkout(s) + the stack env file itself.
  fingerprint:
    git_roots:
      - "."
    extra_files: []
